package main

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: simple.proto_simple
// File Location: rSimple.main.go

import (
	"fmt"

	"github.com/jinzhu/gorm"
	// "gitlab.com/ruangguru/source/simple/config"
	sv "gitlab.com/ruangguru/source/simple/handler"

	// model "gitlab.com/ruangguru/source/simple/model"
	"log"
	"time"

	_ "github.com/go-sql-driver/mysql"
	pb "gitlab.com/ruangguru/source/simple/grpc/proto/simple"
	repo "gitlab.com/ruangguru/source/simple/repo"
	"google.golang.org/grpc"

	"os"

	"context"
	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpc_logrus "github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus"
	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	logrus "github.com/sirupsen/logrus"
	"google.golang.org/grpc/codes"
	"net"
	"net/http"
)

func runHTTP() error {
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	// Register gRPC server endpoint
	// Note: Make sure the gRPC server is running properly and accessible
	mux := runtime.NewServeMux()
	opts := []grpc.DialOption{grpc.WithInsecure()}
	err := pb.RegisterSimpleHandlerFromEndpoint(ctx, mux, "localhost:8080", opts)
	if err != nil {
		return err
	}

	// Start HTTP server (and proxy calls to gRPC server endpoint)
	return http.ListenAndServe(":8081", mux)
}

func InitDB(address string, dbName string) *gorm.DB {
	// init db connection
	dbUser := "root"
	dbPass := "ErGeRj45"
	dbEndpoint := address
	dbPort := "3306"
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local", dbUser, dbPass, dbEndpoint, dbPort, dbName)

	db, err := gorm.Open("mysql", dsn)
	if err != nil {
		log.Fatalf(err.Error())
		panic(err)
	}

	db.LogMode(true)
	db.DB().SetConnMaxLifetime(time.Minute * time.Duration(10))
	db.DB().SetMaxIdleConns(5)
	db.DB().SetMaxOpenConns(50)
	db.SingularTable(true)
	return db
}

// CustomLogger for custome logger
func CustomLogger(code codes.Code) logrus.Level {
	if code == codes.OK {
		return logrus.InfoLevel
	}

	return logrus.WarnLevel
}

func main() {
	// cfg := config.Get()

	db := InitDB("fec-ticketing-stag-mysql.statefulset.svc.cluster.local", "ticketing")
	lis, _ := net.Listen("tcp", ":8080")

	masterRepo := repo.NewMasterRepoService(db)
	masterService := sv.NewSimpleService(masterRepo)

	handler := sv.NewSimple(masterService)

	// setting middleware
	// Logrus entry is used, allowing pre-definition of certain fields by the user.
	// Log as JSON instead of the default ASCII formatter.
	logger := &logrus.Logger{}
	logger.SetFormatter(&logrus.TextFormatter{})
	logger.SetOutput(os.Stdout)
	logger.SetLevel(logrus.InfoLevel)
	customFunc := CustomLogger

	logrusEntry := logrus.NewEntry(logger)
	// Shared options for the logger, with a custom gRPC code to log level function.
	opts := []grpc_logrus.Option{
		grpc_logrus.WithLevels(customFunc),
	}
	grpc_logrus.ReplaceGrpcLogger(logrusEntry)

	s := grpc.NewServer(
		grpc.UnaryInterceptor(
			grpc_middleware.ChainUnaryServer(
				grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
				grpc_logrus.UnaryServerInterceptor(logrusEntry, opts...),
			),
		),
		// atau klo mau single kayka method gt bs kek gini

	)
	pb.RegisterSimpleServer(s, handler)

	go func() {
		if err := s.Serve(lis); err != nil {
			log.Fatalf("failed to serve: %v", err)
		}
	}()

	log.Println("starting server")

	if err := runHTTP(); err != nil {
		log.Fatal(err)
	}
}
