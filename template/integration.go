package template

import lib "github.com/zokypesch/protoc-gen-generator/lib"

var tmplIntegration = `package {{ ucdown (getFirstService .Services).Name }}

// Code generated by sangkuriang protoc-gen-go. DO NOT EDIT.
// source: {{ .FileName }}_{{ .GoPackage }}
// File Location: {{ ucfirst (getFirstService .Services).Name }}.model.go

import (
	"context"

	{{- if .TimeStamp }}
	ptypes "github.com/golang/protobuf/ptypes"
	{{- end}}
	"github.com/zokypesch/proto-lib/core"
	{{- range $msg := .IntegrationMessage }}
	{{- range $field := $msg.Fields }}
	{{- if $field.Integration}}
	pb{{ ucfirst $field.IntegrationCfg.ProtoDomain }} "{{ currentLoc }}/grpc/pb/{{ $field.IntegrationCfg.ProtoDomain }}"
	{{- end }}
	{{- end }}
	{{- end }}
	pb "{{ .Src }}/grpc/pb/{{ .GoPackage }}"
	"google.golang.org/grpc"
	"fmt"
)

{{- range $service := .Services }}
{{- range $method := $service.Methods }}
{{- if $method.HasIntegration }}
func GetIntegration{{ ucfirst $method.Name }}(ctx context.Context, in *pb.{{ ucfirst $method.OutputMessage.Name }}) (*pb.{{ ucfirst $method.OutputMessage.Name }}, error){
	// mapping request
	{{ range $field := $method.OutputMessage.Fields }}
	{{- if $field.Integration }}
	{{- if $field.IsRepeated }}
	{{- else}}
	req{{ $field.IntegrationCfg.Unique }} := &pb{{ ucfirst $field.IntegrationCfg.ProtoDomain }}.{{ ucfirst $field.IntegrationCfg.ResultRequest.Name }}{{unescape "{"}}{{unescape "}"}}
	{{- range $fieldNum := $field.IntegrationCfg.ResultRequest.Fields }}
	
	{{- if $fieldNum.IsRepeated }}
	{{- else }}
	req{{ ucfirst $field.IntegrationCfg.Unique }}.{{ ucfirst $fieldNum.Name }} = in.{{ ucfirst $fieldNum.Name }}
	{{- end }}

	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}

	// mapping functionality
	{{ range $field := $method.OutputMessage.Fields }}
	{{- if $field.Integration }}
	
	conn{{ $field.IntegrationCfg.Unique }}, err := grpc.Dial(fmt.Sprintf("%s:%s", "{{ $field.IntegrationCfg.GrpcAddress }}", "{{ $field.IntegrationCfg.GrpcPort }}"), grpc.WithInsecure())

	if err != nil {
		return in, err
	}
	defer conn{{ $field.IntegrationCfg.Unique }}.Close()

	client{{ $field.IntegrationCfg.Unique }} := pb{{ ucfirst $field.IntegrationCfg.ProtoDomain }}.New{{ ucfirst $field.IntegrationCfg.ProtoDomain }}Client(conn{{ $field.IntegrationCfg.Unique }})
	additionalHeader{{ $field.IntegrationCfg.Unique }} := map[string]string{}
	newCtx{{ $field.IntegrationCfg.Unique }} := core.CreateContextForOutgoing(ctx, additionalHeader{{ $field.IntegrationCfg.Unique }})

	opts{{ $field.IntegrationCfg.Unique }} := []grpc.CallOption{}
	r{{ $field.IntegrationCfg.Unique }}, err := client{{ $field.IntegrationCfg.Unique }}.{{ ucfirst $field.IntegrationCfg.GrpcMethod }}(newCtx{{ $field.IntegrationCfg.Unique }}, req{{ $field.IntegrationCfg.Unique }}, opts{{ $field.IntegrationCfg.Unique }}...)

	if err != nil {
		return in, err
	}

	// mapping response
	{{- if $field.IsRepeated }}
	{{- else }}
	res{{ $field.IntegrationCfg.Unique }} := &pb.{{ ucfirst $field.IntegrationCfg.ResultResponse.Name }}{}
	{{- range $fieldNum := $field.IntegrationCfg.ResultResponse.Fields }}

	{{- if $fieldNum.IsRepeated }}
	{{- else }}
	res{{ $field.IntegrationCfg.Unique }}.{{ ucfirst $fieldNum.Name }} = r{{ $field.IntegrationCfg.Unique }}.{{ ucfirst $fieldNum.Name }}
	{{- end }}
	{{- end }}
	in.{{ ucfirst $field.Name }} = res{{ $field.IntegrationCfg.Unique }}
	{{- end }}
	{{- end }}
	{{- end }}

	return in, nil
}
{{- end}}
{{- end}}
{{- end}}

`

var ListIntegration = lib.List{
	FileType: ".integration.go",
	Template: tmplIntegration,
	Location: "./%s/",
	Lang:     "go",
}
