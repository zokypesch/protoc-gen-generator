package template

import lib "github.com/zokypesch/protoc-gen-generator/lib"

var tmplHandler = `package handler

// Code generated by sangkuriang protoc-gen-go. DO NOT EDIT.
// source: {{ .FileName }}_{{ .GoPackage }}
// File Location: handler/{{ ucfirst (getFirstService .Services).Name }}.handler.go

import  (
	pb "{{ .Src }}/grpc/pb/{{ .GoPackage }}"
	"context"
	{{- if .UseEmptyProto}}
	empty "github.com/golang/protobuf/ptypes/empty"
	{{- end}}
	{{- if .TimeStamp }}
	ptypes "github.com/golang/protobuf/ptypes"
	{{- end}}
	validator "github.com/go-playground/validator"
	domain "{{ .Src }}/{{ ucdown (getFirstService .Services).Name }}"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

{{- range $service := .Services }}
type {{ ucfirst $service.Name }} struct{
	svc *domain.{{ ucfirst $service.Name }}Service
	validate *validator.Validate
	pb.Unimplemented{{ ucfirst $service.Name }}Server
}

func New{{ ucfirst $service.Name }}(svc *domain.{{ ucfirst $service.Name }}Service) *{{ ucfirst $service.Name }} {
	validate := validator.New()
	return &{{ svc: ucfirst $service.Name }}{{ unescape "{" }}svc, validate: validate{{ unescape "}" }}
}

{{- range $method := $service.Methods }}
// {{ ucfirst $method.Name }} method declare by generated code
{{- if eq $method.Input "empty"}}
func (handler *{{ ucfirst $service.Name }}) {{ ucfirst $method.Name }}(ctx context.Context, in *empty.Empty) (*pb.{{ ucfirst $method.Output }}, error) {
{{- else}}
func (handler *{{ ucfirst $service.Name }}) {{ ucfirst $method.Name }}(ctx context.Context, in *pb.{{ ucfirst $method.Input }}) (*pb.{{ ucfirst $method.Output }}, error) {
{{- end}}

{{- if eq $method.Input "empty"}}
{{- else}}
	model := domain.{{ ucfirst $method.Input }}{}

{{- range $field := $method.InputWithAgregator.Fields }}
{{- if $field.RequiredOption}}
{{- if eq $field.TypeDataGo "time.Time"}}
	time{{ ucfirst $field.Name }}, errTime{{ ucfirst $field.Name }} := ptypes.Timestamp(in.{{ ucfirst $field.Name }})

	if errTime{{ ucfirst $field.Name }} == nil {
		model.{{ ucfirst $field.Name }} = time{{ ucfirst $field.Name }}
	}
{{- else }}
	model.{{ ucfirst $field.Name }} = in.{{ ucfirst $field.Name }}
{{- end}}
{{- end}}
{{- end}}

	if err := handler.validate.Struct(model); err != nil {
		return &pb.{{ ucfirst $method.Output }}{}, status.Errorf(codes.InvalidArgument, err.Error())
	}
{{- end}}
	{{- if $method.HasIntegration }}
	reqIntegration, errIntegration := handler.svc.{{ ucfirst $method.Name }}(ctx, in)
	if errIntegration != nil {
		return &pb.{{ ucfirst $method.Output }}{}, errIntegration
	} 
	return domain.GetIntegration{{ ucfirst $method.Name }}(ctx, reqIntegration)
	{{- else }}
	return handler.svc.{{ ucfirst $method.Name }}(ctx, in)
	{{- end }}
}
{{- end}}
{{- end}}

`

var ListHandler = lib.List{
	FileType: ".handler.go",
	Template: tmplHandler,
	Location: "./handler/",
	Lang:     "go",
}
