package template

import lib "github.com/zokypesch/protoc-gen-generator/lib"

var tmplService = `package {{ ucdown (getFirstService .Services).Name }}

// Code generated by sangkuriang protoc-gen-go. DO NOT EDIT.
// source: {{ .FileName }}_{{ .GoPackage }}
// File Location: handler/{{ ucfirst (getFirstService .Services).Name }}.service.go

import  (
	pb "{{ .Src }}/grpc/pb/{{ .GoPackage }}"
	"context"
	{{- if .UseEmptyProto}}
	empty "github.com/golang/protobuf/ptypes/empty"
	{{- end}}
	{{- if .Elastic }}
	core "{{ .Src }}/core"
	{{- end}}
	{{- if .TimeStamp }}
	ptypes "github.com/golang/protobuf/ptypes"
	{{- end}}
)

{{- range $service := .Services }}
type {{ ucfirst $service.Name }}Service struct{
	repo *MasterRepository
	{{if $service.Elastic }}
	{{- range $msg := $service.AllMessage }}
	{{- if $msg.IsElastic }}
	es{{ ucfirst $msg.Name }} core.ESModule
	{{- end}}
	{{- end}}
	{{- end}}
}

// {{ ucfirst $service.Name }}Svc for service singleton
var {{ $service.Name }}Svc *{{ ucfirst $service.Name }}Service

// New{{ ucfirst $service.Name }}Service for new repository service
{{if $service.Elastic }}
func New{{ ucfirst $service.Name }}Service(repo *MasterRepository,{{ $service.MessageAllEs }}) *{{ ucfirst $service.Name }}Service {
{{- else}}
func New{{ ucfirst $service.Name }}Service(repo *MasterRepository) *{{ ucfirst $service.Name }}Service {
{{- end}}
	if {{ $service.Name }}Svc == nil {
		{{ $service.Name }}Svc = &{{ ucfirst $service.Name }}Service{
			repo,
			{{- range $msg := $service.AllMessage }}
			{{- if $msg.IsElastic }}
			es{{ ucfirst $msg.Name }},
			{{- end}}
			{{- end}}
		}
	}
	return {{ $service.Name }}Svc
}

{{- range $method := $service.Methods }}
// {{ ucfirst $method.Name }} method declare by generated code
{{- if eq $method.Input "empty"}}
func (svc *{{ ucfirst $service.Name }}Service) {{ ucfirst $method.Name }}(ctx context.Context, in *empty.Empty) (*pb.{{ ucfirst $method.Output }}, error) {
{{- else}}
func (svc *{{ ucfirst $service.Name }}Service) {{ ucfirst $method.Name }}(ctx context.Context, in *pb.{{ ucfirst $method.Input }}) (*pb.{{ ucfirst $method.Output }}, error) {
{{- end}}

{{- if eq $method.Input "empty"}}
	return &pb.{{ ucfirst $method.Output }}{}, nil
{{- else}}
{{- if $method.IsAgregator}}
	model := &{{ ucfirst $method.AgregatorMessage.Name }}{}
{{- range $field := $method.InputWithAgregator.Fields }}
{{- if eq $field.IgnoreGorm false}}
{{- if eq $field.TypeDataGo "time.Time"}}
	time{{ ucfirst $field.Name }}, errTime{{ ucfirst $field.Name }} := ptypes.Timestamp(in.{{ ucfirst $field.Name }})

	if errTime{{ ucfirst $field.Name }} == nil {
		model.{{ ucfirst $field.Name }} = time{{ ucfirst $field.Name }}
	}
{{- else }}
{{- if $field.IsFieldMessage }}
{{- else }}
	model.{{ ucfirst $field.Name }} = in.{{ ucfirst $field.Name }}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- if eq $method.AgregatorFunction "GetAll"}}
{{- if $method.IsPageLimitFound}}
	res, totalAll, err := svc.repo.{{ ucfirst $method.AgregatorMessage.Name }}.{{ $method.AgregatorFunction }}(model, in.Page, in.PerPage)
{{- else}}
	res, totalAll, err := svc.repo.{{ ucfirst $method.AgregatorMessage.Name }}.{{ $method.AgregatorFunction }}(model, 1, 1000)
{{- end }}
{{- else}}
{{- if $method.IORelated}}
	res, err := svc.repo.{{ ucfirst $method.AgregatorMessage.Name }}.{{ $method.AgregatorFunction }}(model)
{{- else }}
	_, err := svc.repo.{{ ucfirst $method.AgregatorMessage.Name }}.{{ $method.AgregatorFunction }}(model)
{{- end }}
{{- end }}
	resp := &pb.{{ ucfirst $method.Output }}{}

{{- if eq $method.AgregatorFunction "GetAll"}}
{{- if $method.IsGetAllMessage }}
	var resItems []*pb.{{ucfirst $method.AgregatorMessage.Name}}

	for _, vItems := range res {{ unescape "{"}}
		newItem := &pb.{{ucfirst $method.AgregatorMessage.Name}}{{ unescape "{}"}}
{{- range $field := $method.AgregatorMessage.Fields }} 
{{- if eq $field.IgnoreGorm false }}
	{{- if eq $field.TypeDataGo "time.Time"}}
		protoTimeResp{{ ucfirst $field.Name }}, errProtoTimeResp{{ ucfirst $field.Name }} := ptypes.TimestampProto(vItems.{{ ucfirst $field.Name }})

		if errProtoTimeResp{{ ucfirst $field.Name }} == nil {
			newItem.{{ ucfirst $field.Name }} = protoTimeResp{{ ucfirst $field.Name }}
		}
	{{- else }}
	{{- if eq $field.IsFieldMessage true }}
		{{- if $field.IsRepeated }}
		// mapping slice sub struct of {{ucfirst $field.MessageToName}}
		var res{{ucfirst $field.MessageToName}} []*pb.{{ucfirst $field.MessageToName}}
		for _, vItems := range vItems.{{ucfirst $field.MessageToName}} {{ unescape "{"}}
			newItem := &pb.{{ucfirst $field.MessageToName}}{{ unescape "{}"}}
			{{- range $newFieldMsg := $field.MessageTo.Fields}}
			{{- if eq $newFieldMsg.TypeDataGo "time.Time"}}
			protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}, errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} := ptypes.TimestampProto(vItems.{{ ucfirst $newFieldMsg.Name }})

			if errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} == nil {
				newItem.{{ ucfirst $newFieldMsg.Name }} = protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}
			}
			{{- else }}
			{{- if $newFieldMsg.IsFieldMessage }}
			{{- else }}
			newItem.{{ ucfirst $newFieldMsg.Name }} = vItems.{{ ucfirst $newFieldMsg.Name }}
			{{- end}}
			{{- end }}
			{{- end }}
			res{{ucfirst $field.MessageToName}} = append(res{{ucfirst $field.MessageToName}}, newItem)
		{{ unescape "}"}}
		newItem.{{ucfirst $field.MessageToName}} = res{{ucfirst $field.MessageToName }}
		// end mapping slice
		{{- else}}
		{{- if eq $field.MessageToName ""}}
		{{- else}}
		// mapping sub struct of {{ucfirst $field.MessageToName}}
		res{{ucfirst $field.MessageToName}} := &pb.{{ucfirst $field.MessageToName}}{{ unescape "{}"}}
		{{- range $newFieldMsg := $field.MessageTo.Fields}}
		{{- if eq $newFieldMsg.TypeDataGo "time.Time"}}
		protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}, errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} := ptypes.TimestampProto(vItems.{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }})

		if errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} == nil {
			res{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }} = protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}
		}
		{{- else }}
		{{- if $newFieldMsg.IsFieldMessage }}
		{{- else }}
		res{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }} = vItems.{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }}
		{{- end}}
		{{- end}}
		{{- end }}
		newItem.{{ucfirst $field.MessageToName}} = res{{ucfirst $field.MessageToName }}
		// endof mapping of {{ucfirst $field.MessageToName}}
		{{- end }}
		{{- end}}
	{{- else }}
		newItem.{{ ucfirst $field.Name }} = vItems.{{ ucfirst $field.Name }}
	{{- end}}
	{{- end}}
	
{{- end}}
{{- end}}
		
		resItems = append(resItems, newItem) 
	{{ unescape "}"}}
	resp.Items = resItems
	resp.Total = int64(totalAll)
{{- if $method.IsPageLimitFound}}
	resp.Page = in.Page
	resp.PerPage = in.PerPage
{{- end}}
{{- end}}

{{- else}}
{{- range $field := $method.IO.Fields }}
{{- if eq $field.IgnoreGorm false }}

{{- if eq $field.TypeDataGo "time.Time"}}
	protoTimeResp{{ ucfirst $field.Name }}, errProtoTimeResp{{ ucfirst $field.Name }} := ptypes.TimestampProto(res.{{ ucfirst $field.Name }})

	if errProtoTimeResp{{ ucfirst $field.Name }} == nil {
		resp.{{ ucfirst $field.Name }} = protoTimeResp{{ ucfirst $field.Name }}
	}
{{- else }}
{{- if $field.IsFieldMessage }}
{{- if eq $method.AgregatorFunction $method.AgregatorGetByPrimary}}
{{- if $field.IsRepeated }}
	// Mapping sub struct of {{ucfirst $field.MessageToName}}
	var res{{ucfirst $field.MessageToName}} []*pb.{{ucfirst $field.MessageToName}}
	for _, vItems := range res.{{ucfirst $field.MessageToName}} {{ unescape "{"}}
		newItem := &pb.{{ucfirst $field.MessageToName}}{{ unescape "{}"}}
		{{- range $newFieldMsg := $field.MessageTo.Fields}}
		{{- if eq $newFieldMsg.TypeDataGo "time.Time"}}
		protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}, errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} := ptypes.TimestampProto(vItems.{{ ucfirst $newFieldMsg.Name }})

		if errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} == nil {
			newItem.{{ ucfirst $newFieldMsg.Name }} = protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}
		}
		{{- else }}
		{{- if $newFieldMsg.IsFieldMessage }}
		{{- else }}
		newItem.{{ ucfirst $newFieldMsg.Name }} = vItems.{{ ucfirst $newFieldMsg.Name }}
		{{- end}}
		{{- end }}
		{{- end }}
		res{{ucfirst $field.MessageToName}} = append(res{{ucfirst $field.MessageToName}}, newItem)
	{{ unescape "}"}}
	resp.{{ucfirst $field.MessageToName}} = res{{ucfirst $field.MessageToName }}
	// end mapping sub struct of {{ucfirst $field.MessageToName}}
	{{- else}}

	{{- if eq $field.MessageToName ""}}
	{{- else}}
	// Mapping sub struct of {{ucfirst $field.MessageToName}}
	res{{ucfirst $field.MessageToName}} := &pb.{{ucfirst $field.MessageToName}}{{ unescape "{}"}}
	{{- range $newFieldMsg := $field.MessageTo.Fields}}
	{{- if eq $newFieldMsg.TypeDataGo "time.Time"}}
	protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}, errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} := ptypes.TimestampProto(res.{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }})

	if errProtoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }} == nil {
		res{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }} = protoTimeResp{{ucfirst $field.MessageToName}}{{ ucfirst $newFieldMsg.Name }}
	}
	{{- else }}
	{{- if $newFieldMsg.IsFieldMessage }}
	{{- else }}
	res{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }} = res.{{ucfirst $field.MessageToName}}.{{ ucfirst $newFieldMsg.Name }}
	{{- end}}
	{{- end}}
	{{- end }}
	resp.{{ucfirst $field.MessageToName}} = res{{ucfirst $field.MessageToName }}
	// end mapping sub struct of {{ucfirst $field.MessageToName}}
	{{- end }}
	{{- end}}
	{{- end}}
{{- else }}
	resp.{{ ucfirst $field.Name }} = res.{{ ucfirst $field.Name }}
{{- end}}
	
{{- end}}

{{- end}}
{{- end}}
{{- end}}
	return resp, err

{{- else}}
	return &pb.{{ ucfirst $method.Output }}{}, nil
{{- end}}
{{- end}}
}
{{- end}}
{{- end}}

`

var ListService = lib.List{
	FileType: ".service.go",
	Template: tmplService,
	Location: "./%s/",
	Lang:     "go",
}
